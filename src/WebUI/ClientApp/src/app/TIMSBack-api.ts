/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.8.2.0 (NJsonSchema v10.2.1.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAccountClient {
    login(command: GetLoginQuery): Observable<LoginResultDto>;
}

@Injectable({
    providedIn: 'root'
})
export class AccountClient implements IAccountClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    login(command: GetLoginQuery): Observable<LoginResultDto> {
        let url_ = this.baseUrl + "/api/Account";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<LoginResultDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoginResultDto>><any>_observableThrow(response_);
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<LoginResultDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginResultDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoginResultDto>(<any>null);
    }
}

export interface ICategoriesListsClient {
    get(): Observable<Category[]>;
}

@Injectable({
    providedIn: 'root'
})
export class CategoriesListsClient implements ICategoriesListsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Observable<Category[]> {
        let url_ = this.baseUrl + "/api/CategoriesLists";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Category[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Category[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Category[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Category.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Category[]>(<any>null);
    }
}

export interface ICustomerClient {
    get(): Observable<CustomerDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class CustomerClient implements ICustomerClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Observable<CustomerDto[]> {
        let url_ = this.baseUrl + "/api/Customer";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<CustomerDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CustomerDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CustomerDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerDto[]>(<any>null);
    }
}

export interface IHomeClient {
    index(): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class HomeClient implements IHomeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    index(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Home";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIndex(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIndex(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processIndex(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IProductListsClient {
    get(): Observable<ProductListDto[]>;
    getSelected(command: GetSelectedProductsQuery): Observable<PaginationProductListDto>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductListsClient implements IProductListsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Observable<ProductListDto[]> {
        let url_ = this.baseUrl + "/api/ProductLists";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ProductListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ProductListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductListDto[]>(<any>null);
    }

    getSelected(command: GetSelectedProductsQuery): Observable<PaginationProductListDto> {
        let url_ = this.baseUrl + "/api/ProductLists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSelected(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSelected(<any>response_);
                } catch (e) {
                    return <Observable<PaginationProductListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaginationProductListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSelected(response: HttpResponseBase): Observable<PaginationProductListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaginationProductListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaginationProductListDto>(<any>null);
    }
}

export interface IProductsClient {
    create(command: CreateProductCommand): Observable<number>;
    update(id: number, command: UpdateProductCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductsClient implements IProductsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(command: CreateProductCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/Products";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    update(id: number, command: UpdateProductCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Products/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IPurchaseOrderListsClient {
    get(): Observable<PurchasesOrderListDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class PurchaseOrderListsClient implements IPurchaseOrderListsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Observable<PurchasesOrderListDto[]> {
        let url_ = this.baseUrl + "/api/PurchaseOrderLists";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<PurchasesOrderListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PurchasesOrderListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<PurchasesOrderListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PurchasesOrderListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PurchasesOrderListDto[]>(<any>null);
    }
}

export interface ISalesOrderListsClient {
    get(): Observable<SalesOrderListDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class SalesOrderListsClient implements ISalesOrderListsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Observable<SalesOrderListDto[]> {
        let url_ = this.baseUrl + "/api/SalesOrderLists";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<SalesOrderListDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SalesOrderListDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SalesOrderListDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SalesOrderListDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SalesOrderListDto[]>(<any>null);
    }
}

export interface ISupplierClient {
    get(): Observable<SupplierDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class SupplierClient implements ISupplierClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Observable<SupplierDto[]> {
        let url_ = this.baseUrl + "/api/Supplier";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<SupplierDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SupplierDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<SupplierDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SupplierDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SupplierDto[]>(<any>null);
    }
}

export interface ITodoItemsClient {
    create(command: CreateTodoItemCommand): Observable<number>;
    update(id: number, command: UpdateTodoItemCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
    updateItemDetails(id: number | undefined, command: UpdateTodoItemDetailCommand): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class TodoItemsClient implements ITodoItemsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    create(command: CreateTodoItemCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/TodoItems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    update(id: number, command: UpdateTodoItemCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoItems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoItems/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    updateItemDetails(id: number | undefined, command: UpdateTodoItemDetailCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoItems/UpdateItemDetails?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateItemDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateItemDetails(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateItemDetails(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface ITodoListsClient {
    get(): Observable<TodosVm>;
    create(command: CreateTodoListCommand): Observable<number>;
    get2(id: number): Observable<FileResponse>;
    update(id: number, command: UpdateTodoListCommand): Observable<FileResponse>;
    delete(id: number): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class TodoListsClient implements ITodoListsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Observable<TodosVm> {
        let url_ = this.baseUrl + "/api/TodoLists";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TodosVm>><any>_observableThrow(e);
                }
            } else
                return <Observable<TodosVm>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TodosVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TodosVm.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TodosVm>(<any>null);
    }

    create(command: CreateTodoListCommand): Observable<number> {
        let url_ = this.baseUrl + "/api/TodoLists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    get2(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoLists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet2(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGet2(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    update(id: number, command: UpdateTodoListCommand): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoLists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: number): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/TodoLists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface ITrademarksListsClient {
    get(): Observable<Trademark[]>;
}

@Injectable({
    providedIn: 'root'
})
export class TrademarksListsClient implements ITrademarksListsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Observable<Trademark[]> {
        let url_ = this.baseUrl + "/api/TrademarksLists";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<Trademark[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Trademark[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<Trademark[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Trademark.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Trademark[]>(<any>null);
    }
}

export interface IUsersClient {
    authenticate(model: AuthenticateModel): Observable<FileResponse>;
    register(model: RegisterModel): Observable<FileResponse>;
    getAll(): Observable<FileResponse>;
    getById(id: string | null): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class UsersClient implements IUsersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    authenticate(model: AuthenticateModel): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    register(model: RegisterModel): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getAll(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Users";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getById(id: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IWeatherForecastClient {
    get(): Observable<WeatherForecast[]>;
}

@Injectable({
    providedIn: 'root'
})
export class WeatherForecastClient implements IWeatherForecastClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Observable<WeatherForecast[]> {
        let url_ = this.baseUrl + "/api/WeatherForecast";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<WeatherForecast[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeatherForecast[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WeatherForecast[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WeatherForecast.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeatherForecast[]>(<any>null);
    }
}

export interface IWorkOrderClient {
    get(): Observable<WorkOrderDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class WorkOrderClient implements IWorkOrderClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Observable<WorkOrderDto[]> {
        let url_ = this.baseUrl + "/api/WorkOrder";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<WorkOrderDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkOrderDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WorkOrderDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WorkOrderDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkOrderDto[]>(<any>null);
    }
}

export interface IProductsAndServicesClient {
    get(): Observable<ProductsAndServicesDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class ProductsAndServicesClient implements IProductsAndServicesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Observable<ProductsAndServicesDto[]> {
        let url_ = this.baseUrl + "/api/ProductsAndServices";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<ProductsAndServicesDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductsAndServicesDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<ProductsAndServicesDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ProductsAndServicesDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductsAndServicesDto[]>(<any>null);
    }
}

export interface ITransferClient {
    get(): Observable<TransferDto[]>;
}

@Injectable({
    providedIn: 'root'
})
export class TransferClient implements ITransferClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    get(): Observable<TransferDto[]> {
        let url_ = this.baseUrl + "/api/Transfer";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<TransferDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransferDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<TransferDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TransferDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransferDto[]>(<any>null);
    }
}

export class LoginResultDto implements ILoginResultDto {
    token?: string | undefined;

    constructor(data?: ILoginResultDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): LoginResultDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoginResultDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        return data; 
    }
}

export interface ILoginResultDto {
    token?: string | undefined;
}

export class GetLoginQuery implements IGetLoginQuery {
    userName?: string | undefined;
    password?: string | undefined;

    constructor(data?: IGetLoginQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): GetLoginQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetLoginQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data; 
    }
}

export interface IGetLoginQuery {
    userName?: string | undefined;
    password?: string | undefined;
}

export abstract class AuditableEntity implements IAuditableEntity {

    constructor(data?: IAuditableEntity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): AuditableEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AuditableEntity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IAuditableEntity {
}

export class Category extends AuditableEntity implements ICategory {
    categoryId?: number;
    categoryName?: string | undefined;
    productCategories?: ProductCategory[] | undefined;

    constructor(data?: ICategory) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.categoryId = _data["categoryId"];
            this.categoryName = _data["categoryName"];
            if (Array.isArray(_data["productCategories"])) {
                this.productCategories = [] as any;
                for (let item of _data["productCategories"])
                    this.productCategories!.push(ProductCategory.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Category {
        data = typeof data === 'object' ? data : {};
        let result = new Category();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["categoryId"] = this.categoryId;
        data["categoryName"] = this.categoryName;
        if (Array.isArray(this.productCategories)) {
            data["productCategories"] = [];
            for (let item of this.productCategories)
                data["productCategories"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ICategory extends IAuditableEntity {
    categoryId?: number;
    categoryName?: string | undefined;
    productCategories?: ProductCategory[] | undefined;
}

export class ProductCategory extends AuditableEntity implements IProductCategory {
    productCategoryId?: number;
    productId?: number;
    product?: Product | undefined;
    categoryId?: number;
    category?: Category | undefined;

    constructor(data?: IProductCategory) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.productCategoryId = _data["productCategoryId"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.categoryId = _data["categoryId"];
            this.category = _data["category"] ? Category.fromJS(_data["category"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductCategory {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productCategoryId"] = this.productCategoryId;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["categoryId"] = this.categoryId;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IProductCategory extends IAuditableEntity {
    productCategoryId?: number;
    productId?: number;
    product?: Product | undefined;
    categoryId?: number;
    category?: Category | undefined;
}

export class Product extends AuditableEntity implements IProduct {
    productId?: number;
    name?: string | undefined;
    productUnitId?: number;
    productDescription?: ProductDescription | undefined;
    productImage?: ProductImage | undefined;
    productUnit?: ProductUnit | undefined;
    productCategories?: ProductCategory[] | undefined;
    productTrademarks?: ProductTrademark[] | undefined;
    productOnHand?: ProductOnHand | undefined;
    productPrice?: ProductPrice | undefined;

    constructor(data?: IProduct) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.productId = _data["productId"];
            this.name = _data["name"];
            this.productUnitId = _data["productUnitId"];
            this.productDescription = _data["productDescription"] ? ProductDescription.fromJS(_data["productDescription"]) : <any>undefined;
            this.productImage = _data["productImage"] ? ProductImage.fromJS(_data["productImage"]) : <any>undefined;
            this.productUnit = _data["productUnit"] ? ProductUnit.fromJS(_data["productUnit"]) : <any>undefined;
            if (Array.isArray(_data["productCategories"])) {
                this.productCategories = [] as any;
                for (let item of _data["productCategories"])
                    this.productCategories!.push(ProductCategory.fromJS(item));
            }
            if (Array.isArray(_data["productTrademarks"])) {
                this.productTrademarks = [] as any;
                for (let item of _data["productTrademarks"])
                    this.productTrademarks!.push(ProductTrademark.fromJS(item));
            }
            this.productOnHand = _data["productOnHand"] ? ProductOnHand.fromJS(_data["productOnHand"]) : <any>undefined;
            this.productPrice = _data["productPrice"] ? ProductPrice.fromJS(_data["productPrice"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Product {
        data = typeof data === 'object' ? data : {};
        let result = new Product();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["name"] = this.name;
        data["productUnitId"] = this.productUnitId;
        data["productDescription"] = this.productDescription ? this.productDescription.toJSON() : <any>undefined;
        data["productImage"] = this.productImage ? this.productImage.toJSON() : <any>undefined;
        data["productUnit"] = this.productUnit ? this.productUnit.toJSON() : <any>undefined;
        if (Array.isArray(this.productCategories)) {
            data["productCategories"] = [];
            for (let item of this.productCategories)
                data["productCategories"].push(item.toJSON());
        }
        if (Array.isArray(this.productTrademarks)) {
            data["productTrademarks"] = [];
            for (let item of this.productTrademarks)
                data["productTrademarks"].push(item.toJSON());
        }
        data["productOnHand"] = this.productOnHand ? this.productOnHand.toJSON() : <any>undefined;
        data["productPrice"] = this.productPrice ? this.productPrice.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IProduct extends IAuditableEntity {
    productId?: number;
    name?: string | undefined;
    productUnitId?: number;
    productDescription?: ProductDescription | undefined;
    productImage?: ProductImage | undefined;
    productUnit?: ProductUnit | undefined;
    productCategories?: ProductCategory[] | undefined;
    productTrademarks?: ProductTrademark[] | undefined;
    productOnHand?: ProductOnHand | undefined;
    productPrice?: ProductPrice | undefined;
}

export class ProductDescription extends AuditableEntity implements IProductDescription {
    productDescriptionId?: number;
    productId?: number;
    product?: Product | undefined;
    grossWeight?: number;
    barcode?: number;
    mpe?: number;
    sku?: string | undefined;

    constructor(data?: IProductDescription) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.productDescriptionId = _data["productDescriptionId"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.grossWeight = _data["grossWeight"];
            this.barcode = _data["barcode"];
            this.mpe = _data["mpe"];
            this.sku = _data["sku"];
        }
    }

    static fromJS(data: any): ProductDescription {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDescription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productDescriptionId"] = this.productDescriptionId;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["grossWeight"] = this.grossWeight;
        data["barcode"] = this.barcode;
        data["mpe"] = this.mpe;
        data["sku"] = this.sku;
        super.toJSON(data);
        return data; 
    }
}

export interface IProductDescription extends IAuditableEntity {
    productDescriptionId?: number;
    productId?: number;
    product?: Product | undefined;
    grossWeight?: number;
    barcode?: number;
    mpe?: number;
    sku?: string | undefined;
}

export class ProductImage extends AuditableEntity implements IProductImage {
    productImageId?: number;
    productId?: number;
    product?: Product | undefined;
    imageText?: string | undefined;

    constructor(data?: IProductImage) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.productImageId = _data["productImageId"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.imageText = _data["imageText"];
        }
    }

    static fromJS(data: any): ProductImage {
        data = typeof data === 'object' ? data : {};
        let result = new ProductImage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productImageId"] = this.productImageId;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["imageText"] = this.imageText;
        super.toJSON(data);
        return data; 
    }
}

export interface IProductImage extends IAuditableEntity {
    productImageId?: number;
    productId?: number;
    product?: Product | undefined;
    imageText?: string | undefined;
}

export class ProductUnit extends AuditableEntity implements IProductUnit {
    productUnitId?: number;
    unitName?: string | undefined;
    products?: Product[] | undefined;

    constructor(data?: IProductUnit) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.productUnitId = _data["productUnitId"];
            this.unitName = _data["unitName"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(Product.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductUnit {
        data = typeof data === 'object' ? data : {};
        let result = new ProductUnit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productUnitId"] = this.productUnitId;
        data["unitName"] = this.unitName;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IProductUnit extends IAuditableEntity {
    productUnitId?: number;
    unitName?: string | undefined;
    products?: Product[] | undefined;
}

export class ProductTrademark extends AuditableEntity implements IProductTrademark {
    productTrademarkId?: number;
    productId?: number;
    product?: Product | undefined;
    trademarkId?: number;
    trademark?: Trademark | undefined;

    constructor(data?: IProductTrademark) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.productTrademarkId = _data["productTrademarkId"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.trademarkId = _data["trademarkId"];
            this.trademark = _data["trademark"] ? Trademark.fromJS(_data["trademark"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductTrademark {
        data = typeof data === 'object' ? data : {};
        let result = new ProductTrademark();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productTrademarkId"] = this.productTrademarkId;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["trademarkId"] = this.trademarkId;
        data["trademark"] = this.trademark ? this.trademark.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IProductTrademark extends IAuditableEntity {
    productTrademarkId?: number;
    productId?: number;
    product?: Product | undefined;
    trademarkId?: number;
    trademark?: Trademark | undefined;
}

export class Trademark extends AuditableEntity implements ITrademark {
    trademarkId?: number;
    trademarkName?: string | undefined;
    productTrademarks?: ProductTrademark[] | undefined;

    constructor(data?: ITrademark) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.trademarkId = _data["trademarkId"];
            this.trademarkName = _data["trademarkName"];
            if (Array.isArray(_data["productTrademarks"])) {
                this.productTrademarks = [] as any;
                for (let item of _data["productTrademarks"])
                    this.productTrademarks!.push(ProductTrademark.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Trademark {
        data = typeof data === 'object' ? data : {};
        let result = new Trademark();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trademarkId"] = this.trademarkId;
        data["trademarkName"] = this.trademarkName;
        if (Array.isArray(this.productTrademarks)) {
            data["productTrademarks"] = [];
            for (let item of this.productTrademarks)
                data["productTrademarks"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ITrademark extends IAuditableEntity {
    trademarkId?: number;
    trademarkName?: string | undefined;
    productTrademarks?: ProductTrademark[] | undefined;
}

export class ProductOnHand extends AuditableEntity implements IProductOnHand {
    productOnHandId?: number;
    productId?: number;
    product?: Product | undefined;
    onHandCount?: number;
    reservedQuantity?: number;
    commitedQuantity?: number;
    awaitingQuantity?: number;
    wareHouseId?: number;
    documentId?: number | undefined;

    constructor(data?: IProductOnHand) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.productOnHandId = _data["productOnHandId"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.onHandCount = _data["onHandCount"];
            this.reservedQuantity = _data["reservedQuantity"];
            this.commitedQuantity = _data["commitedQuantity"];
            this.awaitingQuantity = _data["awaitingQuantity"];
            this.wareHouseId = _data["wareHouseId"];
            this.documentId = _data["documentId"];
        }
    }

    static fromJS(data: any): ProductOnHand {
        data = typeof data === 'object' ? data : {};
        let result = new ProductOnHand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productOnHandId"] = this.productOnHandId;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["onHandCount"] = this.onHandCount;
        data["reservedQuantity"] = this.reservedQuantity;
        data["commitedQuantity"] = this.commitedQuantity;
        data["awaitingQuantity"] = this.awaitingQuantity;
        data["wareHouseId"] = this.wareHouseId;
        data["documentId"] = this.documentId;
        super.toJSON(data);
        return data; 
    }
}

export interface IProductOnHand extends IAuditableEntity {
    productOnHandId?: number;
    productId?: number;
    product?: Product | undefined;
    onHandCount?: number;
    reservedQuantity?: number;
    commitedQuantity?: number;
    awaitingQuantity?: number;
    wareHouseId?: number;
    documentId?: number | undefined;
}

export class ProductPrice extends AuditableEntity implements IProductPrice {
    productPriceId?: number;
    productId?: number;
    product?: Product | undefined;
    priceTaxExcluded?: number;

    constructor(data?: IProductPrice) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.productPriceId = _data["productPriceId"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.priceTaxExcluded = _data["priceTaxExcluded"];
        }
    }

    static fromJS(data: any): ProductPrice {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPrice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productPriceId"] = this.productPriceId;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["priceTaxExcluded"] = this.priceTaxExcluded;
        super.toJSON(data);
        return data; 
    }
}

export interface IProductPrice extends IAuditableEntity {
    productPriceId?: number;
    productId?: number;
    product?: Product | undefined;
    priceTaxExcluded?: number;
}

export class BaseId implements IBaseId {
    id?: number;

    constructor(data?: IBaseId) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): BaseId {
        data = typeof data === 'object' ? data : {};
        let result = new BaseId();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IBaseId {
    id?: number;
}

export class BaseIdName extends BaseId implements IBaseIdName {
    name?: string | undefined;

    constructor(data?: IBaseIdName) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): BaseIdName {
        data = typeof data === 'object' ? data : {};
        let result = new BaseIdName();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        super.toJSON(data);
        return data; 
    }
}

export interface IBaseIdName extends IBaseId {
    name?: string | undefined;
}

export class CustomerDto extends BaseIdName implements ICustomerDto {
    email?: string | undefined;
    city?: string | undefined;
    country?: string | undefined;
    categoryCustomerId?: number;
    categoryCustomer?: string | undefined;
    priceTierId?: number;
    priceTier?: string | undefined;
    taxLocation?: string | undefined;
    termsOfPaymentId?: number;
    termsOfPayment?: string | undefined;
    theyOwnYou?: number;
    youOwnThem?: number;
    balance?: number;

    constructor(data?: ICustomerDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.email = _data["email"];
            this.city = _data["city"];
            this.country = _data["country"];
            this.categoryCustomerId = _data["categoryCustomerId"];
            this.categoryCustomer = _data["categoryCustomer"];
            this.priceTierId = _data["priceTierId"];
            this.priceTier = _data["priceTier"];
            this.taxLocation = _data["taxLocation"];
            this.termsOfPaymentId = _data["termsOfPaymentId"];
            this.termsOfPayment = _data["termsOfPayment"];
            this.theyOwnYou = _data["theyOwnYou"];
            this.youOwnThem = _data["youOwnThem"];
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): CustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["city"] = this.city;
        data["country"] = this.country;
        data["categoryCustomerId"] = this.categoryCustomerId;
        data["categoryCustomer"] = this.categoryCustomer;
        data["priceTierId"] = this.priceTierId;
        data["priceTier"] = this.priceTier;
        data["taxLocation"] = this.taxLocation;
        data["termsOfPaymentId"] = this.termsOfPaymentId;
        data["termsOfPayment"] = this.termsOfPayment;
        data["theyOwnYou"] = this.theyOwnYou;
        data["youOwnThem"] = this.youOwnThem;
        data["balance"] = this.balance;
        super.toJSON(data);
        return data; 
    }
}

export interface ICustomerDto extends IBaseIdName {
    email?: string | undefined;
    city?: string | undefined;
    country?: string | undefined;
    categoryCustomerId?: number;
    categoryCustomer?: string | undefined;
    priceTierId?: number;
    priceTier?: string | undefined;
    taxLocation?: string | undefined;
    termsOfPaymentId?: number;
    termsOfPayment?: string | undefined;
    theyOwnYou?: number;
    youOwnThem?: number;
    balance?: number;
}

export class ProductListDto implements IProductListDto {
    name?: string | undefined;
    items?: Product[] | undefined;
    productId?: number;
    productName?: string | undefined;
    grossWeight?: number;
    sku?: string | undefined;
    barcode?: number;
    mpe?: number;
    photo?: string | undefined;
    unit?: string | undefined;
    category?: string | undefined;
    trademark?: string | undefined;
    onHand?: number;
    price?: number;
    trademarkId?: number;
    categoryId?: number;

    constructor(data?: IProductListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Product.fromJS(item));
            }
            this.productId = _data["productId"];
            this.productName = _data["productName"];
            this.grossWeight = _data["grossWeight"];
            this.sku = _data["sku"];
            this.barcode = _data["barcode"];
            this.mpe = _data["mpe"];
            this.photo = _data["photo"];
            this.unit = _data["unit"];
            this.category = _data["category"];
            this.trademark = _data["trademark"];
            this.onHand = _data["onHand"];
            this.price = _data["price"];
            this.trademarkId = _data["trademarkId"];
            this.categoryId = _data["categoryId"];
        }
    }

    static fromJS(data: any): ProductListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["productId"] = this.productId;
        data["productName"] = this.productName;
        data["grossWeight"] = this.grossWeight;
        data["sku"] = this.sku;
        data["barcode"] = this.barcode;
        data["mpe"] = this.mpe;
        data["photo"] = this.photo;
        data["unit"] = this.unit;
        data["category"] = this.category;
        data["trademark"] = this.trademark;
        data["onHand"] = this.onHand;
        data["price"] = this.price;
        data["trademarkId"] = this.trademarkId;
        data["categoryId"] = this.categoryId;
        return data; 
    }
}

export interface IProductListDto {
    name?: string | undefined;
    items?: Product[] | undefined;
    productId?: number;
    productName?: string | undefined;
    grossWeight?: number;
    sku?: string | undefined;
    barcode?: number;
    mpe?: number;
    photo?: string | undefined;
    unit?: string | undefined;
    category?: string | undefined;
    trademark?: string | undefined;
    onHand?: number;
    price?: number;
    trademarkId?: number;
    categoryId?: number;
}

export class PaginationProductListDto implements IPaginationProductListDto {
    products?: ProductListDto[] | undefined;
    pageCount?: number;

    constructor(data?: IPaginationProductListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(ProductListDto.fromJS(item));
            }
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): PaginationProductListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaginationProductListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        data["pageCount"] = this.pageCount;
        return data; 
    }
}

export interface IPaginationProductListDto {
    products?: ProductListDto[] | undefined;
    pageCount?: number;
}

export class GetSelectedProductsQuery implements IGetSelectedProductsQuery {
    pageNumber?: number;
    pageSize?: number;
    selectedTrademarks?: number[] | undefined;
    selectedCategories?: number[] | undefined;

    constructor(data?: IGetSelectedProductsQuery) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["selectedTrademarks"])) {
                this.selectedTrademarks = [] as any;
                for (let item of _data["selectedTrademarks"])
                    this.selectedTrademarks!.push(item);
            }
            if (Array.isArray(_data["selectedCategories"])) {
                this.selectedCategories = [] as any;
                for (let item of _data["selectedCategories"])
                    this.selectedCategories!.push(item);
            }
        }
    }

    static fromJS(data: any): GetSelectedProductsQuery {
        data = typeof data === 'object' ? data : {};
        let result = new GetSelectedProductsQuery();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.selectedTrademarks)) {
            data["selectedTrademarks"] = [];
            for (let item of this.selectedTrademarks)
                data["selectedTrademarks"].push(item);
        }
        if (Array.isArray(this.selectedCategories)) {
            data["selectedCategories"] = [];
            for (let item of this.selectedCategories)
                data["selectedCategories"].push(item);
        }
        return data; 
    }
}

export interface IGetSelectedProductsQuery {
    pageNumber?: number;
    pageSize?: number;
    selectedTrademarks?: number[] | undefined;
    selectedCategories?: number[] | undefined;
}

export class CreateProductCommand implements ICreateProductCommand {
    productId?: number;
    name?: string | undefined;

    constructor(data?: ICreateProductCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CreateProductCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateProductCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["name"] = this.name;
        return data; 
    }
}

export interface ICreateProductCommand {
    productId?: number;
    name?: string | undefined;
}

export class UpdateProductCommand implements IUpdateProductCommand {
    productId?: number;
    name?: string | undefined;
    productUnitId?: number;

    constructor(data?: IUpdateProductCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productId = _data["productId"];
            this.name = _data["name"];
            this.productUnitId = _data["productUnitId"];
        }
    }

    static fromJS(data: any): UpdateProductCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProductCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["productId"] = this.productId;
        data["name"] = this.name;
        data["productUnitId"] = this.productUnitId;
        return data; 
    }
}

export interface IUpdateProductCommand {
    productId?: number;
    name?: string | undefined;
    productUnitId?: number;
}

export class PurchasesOrderListDto implements IPurchasesOrderListDto {
    id?: number;
    tag?: string | undefined;
    date?: Date;
    supplierId?: number;
    supplierName?: string | undefined;
    statusId?: number;
    statusName?: string | undefined;
    quantityStatusId?: number;
    quantityStatusName?: string | undefined;
    shippingStatusId?: number;
    paymentStatusName?: string | undefined;
    paymentStatusId?: number;
    amount?: number | undefined;
    amountTaxIncl?: number | undefined;
    unpaidAmount?: number | undefined;
    advancePayment?: number | undefined;
    wareHouseId?: number;
    wareHouseName?: string | undefined;
    cash?: number | undefined;
    creditCard?: number | undefined;

    constructor(data?: IPurchasesOrderListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tag = _data["tag"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.supplierId = _data["supplierId"];
            this.supplierName = _data["supplierName"];
            this.statusId = _data["statusId"];
            this.statusName = _data["statusName"];
            this.quantityStatusId = _data["quantityStatusId"];
            this.quantityStatusName = _data["quantityStatusName"];
            this.shippingStatusId = _data["shippingStatusId"];
            this.paymentStatusName = _data["paymentStatusName"];
            this.paymentStatusId = _data["paymentStatusId"];
            this.amount = _data["amount"];
            this.amountTaxIncl = _data["amountTaxIncl"];
            this.unpaidAmount = _data["unpaidAmount"];
            this.advancePayment = _data["advancePayment"];
            this.wareHouseId = _data["wareHouseId"];
            this.wareHouseName = _data["wareHouseName"];
            this.cash = _data["cash"];
            this.creditCard = _data["creditCard"];
        }
    }

    static fromJS(data: any): PurchasesOrderListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchasesOrderListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tag"] = this.tag;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["supplierId"] = this.supplierId;
        data["supplierName"] = this.supplierName;
        data["statusId"] = this.statusId;
        data["statusName"] = this.statusName;
        data["quantityStatusId"] = this.quantityStatusId;
        data["quantityStatusName"] = this.quantityStatusName;
        data["shippingStatusId"] = this.shippingStatusId;
        data["paymentStatusName"] = this.paymentStatusName;
        data["paymentStatusId"] = this.paymentStatusId;
        data["amount"] = this.amount;
        data["amountTaxIncl"] = this.amountTaxIncl;
        data["unpaidAmount"] = this.unpaidAmount;
        data["advancePayment"] = this.advancePayment;
        data["wareHouseId"] = this.wareHouseId;
        data["wareHouseName"] = this.wareHouseName;
        data["cash"] = this.cash;
        data["creditCard"] = this.creditCard;
        return data; 
    }
}

export interface IPurchasesOrderListDto {
    id?: number;
    tag?: string | undefined;
    date?: Date;
    supplierId?: number;
    supplierName?: string | undefined;
    statusId?: number;
    statusName?: string | undefined;
    quantityStatusId?: number;
    quantityStatusName?: string | undefined;
    shippingStatusId?: number;
    paymentStatusName?: string | undefined;
    paymentStatusId?: number;
    amount?: number | undefined;
    amountTaxIncl?: number | undefined;
    unpaidAmount?: number | undefined;
    advancePayment?: number | undefined;
    wareHouseId?: number;
    wareHouseName?: string | undefined;
    cash?: number | undefined;
    creditCard?: number | undefined;
}

export class SalesOrderListDto implements ISalesOrderListDto {
    id?: number;
    tag?: string | undefined;
    date?: Date;
    customerId?: number;
    customerName?: string | undefined;
    statusId?: number;
    statusName?: string | undefined;
    quantityStatusId?: number;
    quantityStatusName?: string | undefined;
    shippingStatusId?: number;
    paymentStatusName?: string | undefined;
    paymentStatusId?: number;
    amount?: number | undefined;
    amountTaxIncl?: number | undefined;
    unpaidAmount?: number | undefined;
    advancePayment?: number | undefined;
    wareHouseId?: number;
    wareHouseName?: string | undefined;
    cash?: number | undefined;
    creditCard?: number | undefined;

    constructor(data?: ISalesOrderListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tag = _data["tag"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.customerId = _data["customerId"];
            this.customerName = _data["customerName"];
            this.statusId = _data["statusId"];
            this.statusName = _data["statusName"];
            this.quantityStatusId = _data["quantityStatusId"];
            this.quantityStatusName = _data["quantityStatusName"];
            this.shippingStatusId = _data["shippingStatusId"];
            this.paymentStatusName = _data["paymentStatusName"];
            this.paymentStatusId = _data["paymentStatusId"];
            this.amount = _data["amount"];
            this.amountTaxIncl = _data["amountTaxIncl"];
            this.unpaidAmount = _data["unpaidAmount"];
            this.advancePayment = _data["advancePayment"];
            this.wareHouseId = _data["wareHouseId"];
            this.wareHouseName = _data["wareHouseName"];
            this.cash = _data["cash"];
            this.creditCard = _data["creditCard"];
        }
    }

    static fromJS(data: any): SalesOrderListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesOrderListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tag"] = this.tag;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["customerId"] = this.customerId;
        data["customerName"] = this.customerName;
        data["statusId"] = this.statusId;
        data["statusName"] = this.statusName;
        data["quantityStatusId"] = this.quantityStatusId;
        data["quantityStatusName"] = this.quantityStatusName;
        data["shippingStatusId"] = this.shippingStatusId;
        data["paymentStatusName"] = this.paymentStatusName;
        data["paymentStatusId"] = this.paymentStatusId;
        data["amount"] = this.amount;
        data["amountTaxIncl"] = this.amountTaxIncl;
        data["unpaidAmount"] = this.unpaidAmount;
        data["advancePayment"] = this.advancePayment;
        data["wareHouseId"] = this.wareHouseId;
        data["wareHouseName"] = this.wareHouseName;
        data["cash"] = this.cash;
        data["creditCard"] = this.creditCard;
        return data; 
    }
}

export interface ISalesOrderListDto {
    id?: number;
    tag?: string | undefined;
    date?: Date;
    customerId?: number;
    customerName?: string | undefined;
    statusId?: number;
    statusName?: string | undefined;
    quantityStatusId?: number;
    quantityStatusName?: string | undefined;
    shippingStatusId?: number;
    paymentStatusName?: string | undefined;
    paymentStatusId?: number;
    amount?: number | undefined;
    amountTaxIncl?: number | undefined;
    unpaidAmount?: number | undefined;
    advancePayment?: number | undefined;
    wareHouseId?: number;
    wareHouseName?: string | undefined;
    cash?: number | undefined;
    creditCard?: number | undefined;
}

export class SupplierDto extends BaseIdName implements ISupplierDto {
    email?: string | undefined;
    city?: string | undefined;
    country?: string | undefined;
    categorySupplierId?: number;
    categorySupplier?: string | undefined;
    taxLocation?: string | undefined;
    termsOfPaymentId?: number;
    termsOfPayment?: string | undefined;
    theyOwnYou?: number;
    youOwnThem?: number;
    balance?: number;

    constructor(data?: ISupplierDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.email = _data["email"];
            this.city = _data["city"];
            this.country = _data["country"];
            this.categorySupplierId = _data["categorySupplierId"];
            this.categorySupplier = _data["categorySupplier"];
            this.taxLocation = _data["taxLocation"];
            this.termsOfPaymentId = _data["termsOfPaymentId"];
            this.termsOfPayment = _data["termsOfPayment"];
            this.theyOwnYou = _data["theyOwnYou"];
            this.youOwnThem = _data["youOwnThem"];
            this.balance = _data["balance"];
        }
    }

    static fromJS(data: any): SupplierDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupplierDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["city"] = this.city;
        data["country"] = this.country;
        data["categorySupplierId"] = this.categorySupplierId;
        data["categorySupplier"] = this.categorySupplier;
        data["taxLocation"] = this.taxLocation;
        data["termsOfPaymentId"] = this.termsOfPaymentId;
        data["termsOfPayment"] = this.termsOfPayment;
        data["theyOwnYou"] = this.theyOwnYou;
        data["youOwnThem"] = this.youOwnThem;
        data["balance"] = this.balance;
        super.toJSON(data);
        return data; 
    }
}

export interface ISupplierDto extends IBaseIdName {
    email?: string | undefined;
    city?: string | undefined;
    country?: string | undefined;
    categorySupplierId?: number;
    categorySupplier?: string | undefined;
    taxLocation?: string | undefined;
    termsOfPaymentId?: number;
    termsOfPayment?: string | undefined;
    theyOwnYou?: number;
    youOwnThem?: number;
    balance?: number;
}

export class CreateTodoItemCommand implements ICreateTodoItemCommand {
    listId?: number;
    title?: string | undefined;

    constructor(data?: ICreateTodoItemCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.listId = _data["listId"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): CreateTodoItemCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTodoItemCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["listId"] = this.listId;
        data["title"] = this.title;
        return data; 
    }
}

export interface ICreateTodoItemCommand {
    listId?: number;
    title?: string | undefined;
}

export class UpdateTodoItemCommand implements IUpdateTodoItemCommand {
    id?: number;
    title?: string | undefined;
    done?: boolean;

    constructor(data?: IUpdateTodoItemCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.done = _data["done"];
        }
    }

    static fromJS(data: any): UpdateTodoItemCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoItemCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["done"] = this.done;
        return data; 
    }
}

export interface IUpdateTodoItemCommand {
    id?: number;
    title?: string | undefined;
    done?: boolean;
}

export class UpdateTodoItemDetailCommand implements IUpdateTodoItemDetailCommand {
    id?: number;
    listId?: number;
    priority?: PriorityLevel;
    note?: string | undefined;

    constructor(data?: IUpdateTodoItemDetailCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.listId = _data["listId"];
            this.priority = _data["priority"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): UpdateTodoItemDetailCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoItemDetailCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["listId"] = this.listId;
        data["priority"] = this.priority;
        data["note"] = this.note;
        return data; 
    }
}

export interface IUpdateTodoItemDetailCommand {
    id?: number;
    listId?: number;
    priority?: PriorityLevel;
    note?: string | undefined;
}

export enum PriorityLevel {
    None = 0,
    Low = 1,
    Medium = 2,
    High = 3,
}

export class TodosVm implements ITodosVm {
    priorityLevels?: PriorityLevelDto[] | undefined;
    lists?: TodoListDto[] | undefined;

    constructor(data?: ITodosVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["priorityLevels"])) {
                this.priorityLevels = [] as any;
                for (let item of _data["priorityLevels"])
                    this.priorityLevels!.push(PriorityLevelDto.fromJS(item));
            }
            if (Array.isArray(_data["lists"])) {
                this.lists = [] as any;
                for (let item of _data["lists"])
                    this.lists!.push(TodoListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TodosVm {
        data = typeof data === 'object' ? data : {};
        let result = new TodosVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.priorityLevels)) {
            data["priorityLevels"] = [];
            for (let item of this.priorityLevels)
                data["priorityLevels"].push(item.toJSON());
        }
        if (Array.isArray(this.lists)) {
            data["lists"] = [];
            for (let item of this.lists)
                data["lists"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITodosVm {
    priorityLevels?: PriorityLevelDto[] | undefined;
    lists?: TodoListDto[] | undefined;
}

export class PriorityLevelDto implements IPriorityLevelDto {
    value?: number;
    name?: string | undefined;

    constructor(data?: IPriorityLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): PriorityLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new PriorityLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["name"] = this.name;
        return data; 
    }
}

export interface IPriorityLevelDto {
    value?: number;
    name?: string | undefined;
}

export class TodoListDto implements ITodoListDto {
    id?: number;
    title?: string | undefined;
    items?: TodoItemDto[] | undefined;

    constructor(data?: ITodoListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TodoItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TodoListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TodoListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITodoListDto {
    id?: number;
    title?: string | undefined;
    items?: TodoItemDto[] | undefined;
}

export class TodoItemDto implements ITodoItemDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;
    priority?: number;
    note?: string | undefined;

    constructor(data?: ITodoItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.listId = _data["listId"];
            this.title = _data["title"];
            this.done = _data["done"];
            this.priority = _data["priority"];
            this.note = _data["note"];
        }
    }

    static fromJS(data: any): TodoItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new TodoItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["listId"] = this.listId;
        data["title"] = this.title;
        data["done"] = this.done;
        data["priority"] = this.priority;
        data["note"] = this.note;
        return data; 
    }
}

export interface ITodoItemDto {
    id?: number;
    listId?: number;
    title?: string | undefined;
    done?: boolean;
    priority?: number;
    note?: string | undefined;
}

export class CreateTodoListCommand implements ICreateTodoListCommand {
    title?: string | undefined;

    constructor(data?: ICreateTodoListCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): CreateTodoListCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTodoListCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        return data; 
    }
}

export interface ICreateTodoListCommand {
    title?: string | undefined;
}

export class UpdateTodoListCommand implements IUpdateTodoListCommand {
    id?: number;
    title?: string | undefined;

    constructor(data?: IUpdateTodoListCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): UpdateTodoListCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTodoListCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        return data; 
    }
}

export interface IUpdateTodoListCommand {
    id?: number;
    title?: string | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userName!: string;
    password!: string;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data; 
    }
}

export interface IAuthenticateModel {
    userName: string;
    password: string;
}

export class RegisterModel extends AuthenticateModel implements IRegisterModel {
    firstName!: string;
    lastName!: string;

    constructor(data?: IRegisterModel) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
        }
    }

    static fromJS(data: any): RegisterModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        super.toJSON(data);
        return data; 
    }
}

export interface IRegisterModel extends IAuthenticateModel {
    firstName: string;
    lastName: string;
}

export class WeatherForecast implements IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.temperatureC = _data["temperatureC"];
            this.temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data; 
    }
}

export interface IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;
}

export class WorkOrder extends BaseIdName implements IWorkOrder {
    date?: Date;
    statusId?: number;
    status?: Status | undefined;
    quantityStatusId?: number;
    quantityStatus?: QuantityStatus | undefined;
    materialLoading?: number;
    finishedGood?: number;
    estimatedCost?: number;
    inputWareHouseId?: number;
    outWareHouseId?: number;

    constructor(data?: IWorkOrder) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.statusId = _data["statusId"];
            this.status = _data["status"] ? Status.fromJS(_data["status"]) : <any>undefined;
            this.quantityStatusId = _data["quantityStatusId"];
            this.quantityStatus = _data["quantityStatus"] ? QuantityStatus.fromJS(_data["quantityStatus"]) : <any>undefined;
            this.materialLoading = _data["materialLoading"];
            this.finishedGood = _data["finishedGood"];
            this.estimatedCost = _data["estimatedCost"];
            this.inputWareHouseId = _data["inputWareHouseId"];
            this.outWareHouseId = _data["outWareHouseId"];
        }
    }

    static fromJS(data: any): WorkOrder {
        data = typeof data === 'object' ? data : {};
        let result = new WorkOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["statusId"] = this.statusId;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["quantityStatusId"] = this.quantityStatusId;
        data["quantityStatus"] = this.quantityStatus ? this.quantityStatus.toJSON() : <any>undefined;
        data["materialLoading"] = this.materialLoading;
        data["finishedGood"] = this.finishedGood;
        data["estimatedCost"] = this.estimatedCost;
        data["inputWareHouseId"] = this.inputWareHouseId;
        data["outWareHouseId"] = this.outWareHouseId;
        super.toJSON(data);
        return data; 
    }
}

export interface IWorkOrder extends IBaseIdName {
    date?: Date;
    statusId?: number;
    status?: Status | undefined;
    quantityStatusId?: number;
    quantityStatus?: QuantityStatus | undefined;
    materialLoading?: number;
    finishedGood?: number;
    estimatedCost?: number;
    inputWareHouseId?: number;
    outWareHouseId?: number;
}

export class WorkOrderDto extends WorkOrder implements IWorkOrderDto {
    statusName?: string | undefined;
    quantityStatusName?: string | undefined;
    inputWareHouseName?: string | undefined;
    outWareHouseName?: string | undefined;

    constructor(data?: IWorkOrderDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.statusName = _data["statusName"];
            this.quantityStatusName = _data["quantityStatusName"];
            this.inputWareHouseName = _data["inputWareHouseName"];
            this.outWareHouseName = _data["outWareHouseName"];
        }
    }

    static fromJS(data: any): WorkOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusName"] = this.statusName;
        data["quantityStatusName"] = this.quantityStatusName;
        data["inputWareHouseName"] = this.inputWareHouseName;
        data["outWareHouseName"] = this.outWareHouseName;
        super.toJSON(data);
        return data; 
    }
}

export interface IWorkOrderDto extends IWorkOrder {
    statusName?: string | undefined;
    quantityStatusName?: string | undefined;
    inputWareHouseName?: string | undefined;
    outWareHouseName?: string | undefined;
}

export class Status extends BaseIdName implements IStatus {
    transfers?: Transfer[] | undefined;

    constructor(data?: IStatus) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["transfers"])) {
                this.transfers = [] as any;
                for (let item of _data["transfers"])
                    this.transfers!.push(Transfer.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Status {
        data = typeof data === 'object' ? data : {};
        let result = new Status();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.transfers)) {
            data["transfers"] = [];
            for (let item of this.transfers)
                data["transfers"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IStatus extends IBaseIdName {
    transfers?: Transfer[] | undefined;
}

export class Transfer extends BaseIdName implements ITransfer {
    date?: Date;
    statusId?: number;
    status?: Status | undefined;
    quantityStatusId?: number;
    quantityStatus?: QuantityStatus | undefined;
    sentQuantity?: number;
    receivedQuantity?: number;
    stockAmount?: number;
    sourceWareHouseId?: number;
    sourceWareHouse?: WareHouse | undefined;
    destinationWareHouseId?: number;
    destinationWareHouse?: WareHouse | undefined;

    constructor(data?: ITransfer) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.statusId = _data["statusId"];
            this.status = _data["status"] ? Status.fromJS(_data["status"]) : <any>undefined;
            this.quantityStatusId = _data["quantityStatusId"];
            this.quantityStatus = _data["quantityStatus"] ? QuantityStatus.fromJS(_data["quantityStatus"]) : <any>undefined;
            this.sentQuantity = _data["sentQuantity"];
            this.receivedQuantity = _data["receivedQuantity"];
            this.stockAmount = _data["stockAmount"];
            this.sourceWareHouseId = _data["sourceWareHouseId"];
            this.sourceWareHouse = _data["sourceWareHouse"] ? WareHouse.fromJS(_data["sourceWareHouse"]) : <any>undefined;
            this.destinationWareHouseId = _data["destinationWareHouseId"];
            this.destinationWareHouse = _data["destinationWareHouse"] ? WareHouse.fromJS(_data["destinationWareHouse"]) : <any>undefined;
        }
    }

    static fromJS(data: any): Transfer {
        data = typeof data === 'object' ? data : {};
        let result = new Transfer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["statusId"] = this.statusId;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["quantityStatusId"] = this.quantityStatusId;
        data["quantityStatus"] = this.quantityStatus ? this.quantityStatus.toJSON() : <any>undefined;
        data["sentQuantity"] = this.sentQuantity;
        data["receivedQuantity"] = this.receivedQuantity;
        data["stockAmount"] = this.stockAmount;
        data["sourceWareHouseId"] = this.sourceWareHouseId;
        data["sourceWareHouse"] = this.sourceWareHouse ? this.sourceWareHouse.toJSON() : <any>undefined;
        data["destinationWareHouseId"] = this.destinationWareHouseId;
        data["destinationWareHouse"] = this.destinationWareHouse ? this.destinationWareHouse.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface ITransfer extends IBaseIdName {
    date?: Date;
    statusId?: number;
    status?: Status | undefined;
    quantityStatusId?: number;
    quantityStatus?: QuantityStatus | undefined;
    sentQuantity?: number;
    receivedQuantity?: number;
    stockAmount?: number;
    sourceWareHouseId?: number;
    sourceWareHouse?: WareHouse | undefined;
    destinationWareHouseId?: number;
    destinationWareHouse?: WareHouse | undefined;
}

export class QuantityStatus extends BaseIdName implements IQuantityStatus {
    transfers?: Transfer[] | undefined;

    constructor(data?: IQuantityStatus) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["transfers"])) {
                this.transfers = [] as any;
                for (let item of _data["transfers"])
                    this.transfers!.push(Transfer.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QuantityStatus {
        data = typeof data === 'object' ? data : {};
        let result = new QuantityStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.transfers)) {
            data["transfers"] = [];
            for (let item of this.transfers)
                data["transfers"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IQuantityStatus extends IBaseIdName {
    transfers?: Transfer[] | undefined;
}

export class WareHouse extends BaseIdName implements IWareHouse {
    sourceWareHouses?: Transfer[] | undefined;
    destinationWareHouses?: Transfer[] | undefined;

    constructor(data?: IWareHouse) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["sourceWareHouses"])) {
                this.sourceWareHouses = [] as any;
                for (let item of _data["sourceWareHouses"])
                    this.sourceWareHouses!.push(Transfer.fromJS(item));
            }
            if (Array.isArray(_data["destinationWareHouses"])) {
                this.destinationWareHouses = [] as any;
                for (let item of _data["destinationWareHouses"])
                    this.destinationWareHouses!.push(Transfer.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WareHouse {
        data = typeof data === 'object' ? data : {};
        let result = new WareHouse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sourceWareHouses)) {
            data["sourceWareHouses"] = [];
            for (let item of this.sourceWareHouses)
                data["sourceWareHouses"].push(item.toJSON());
        }
        if (Array.isArray(this.destinationWareHouses)) {
            data["destinationWareHouses"] = [];
            for (let item of this.destinationWareHouses)
                data["destinationWareHouses"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IWareHouse extends IBaseIdName {
    sourceWareHouses?: Transfer[] | undefined;
    destinationWareHouses?: Transfer[] | undefined;
}

export class ProductsAndServicesDto implements IProductsAndServicesDto {
    name?: string | undefined;
    productId?: number;
    productName?: string | undefined;
    grossWeight?: number;
    sku?: string | undefined;
    barcode?: number;
    mpe?: number;
    photo?: string | undefined;
    unit?: string | undefined;
    category?: string | undefined;
    trademark?: string | undefined;
    onHand?: number;
    price?: number;
    trademarkId?: number;
    categoryId?: number;
    reservedQuantity?: number;
    commitedQuantity?: number;
    awaitingQuantity?: number;
    wareHouseId?: number;
    wareHouseName?: string | undefined;
    documentId?: number | undefined;

    constructor(data?: IProductsAndServicesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.productId = _data["productId"];
            this.productName = _data["productName"];
            this.grossWeight = _data["grossWeight"];
            this.sku = _data["sku"];
            this.barcode = _data["barcode"];
            this.mpe = _data["mpe"];
            this.photo = _data["photo"];
            this.unit = _data["unit"];
            this.category = _data["category"];
            this.trademark = _data["trademark"];
            this.onHand = _data["onHand"];
            this.price = _data["price"];
            this.trademarkId = _data["trademarkId"];
            this.categoryId = _data["categoryId"];
            this.reservedQuantity = _data["reservedQuantity"];
            this.commitedQuantity = _data["commitedQuantity"];
            this.awaitingQuantity = _data["awaitingQuantity"];
            this.wareHouseId = _data["wareHouseId"];
            this.wareHouseName = _data["wareHouseName"];
            this.documentId = _data["documentId"];
        }
    }

    static fromJS(data: any): ProductsAndServicesDto {
        data = typeof data === 'object' ? data : {};
        let result = new ProductsAndServicesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["productId"] = this.productId;
        data["productName"] = this.productName;
        data["grossWeight"] = this.grossWeight;
        data["sku"] = this.sku;
        data["barcode"] = this.barcode;
        data["mpe"] = this.mpe;
        data["photo"] = this.photo;
        data["unit"] = this.unit;
        data["category"] = this.category;
        data["trademark"] = this.trademark;
        data["onHand"] = this.onHand;
        data["price"] = this.price;
        data["trademarkId"] = this.trademarkId;
        data["categoryId"] = this.categoryId;
        data["reservedQuantity"] = this.reservedQuantity;
        data["commitedQuantity"] = this.commitedQuantity;
        data["awaitingQuantity"] = this.awaitingQuantity;
        data["wareHouseId"] = this.wareHouseId;
        data["wareHouseName"] = this.wareHouseName;
        data["documentId"] = this.documentId;
        return data; 
    }
}

export interface IProductsAndServicesDto {
    name?: string | undefined;
    productId?: number;
    productName?: string | undefined;
    grossWeight?: number;
    sku?: string | undefined;
    barcode?: number;
    mpe?: number;
    photo?: string | undefined;
    unit?: string | undefined;
    category?: string | undefined;
    trademark?: string | undefined;
    onHand?: number;
    price?: number;
    trademarkId?: number;
    categoryId?: number;
    reservedQuantity?: number;
    commitedQuantity?: number;
    awaitingQuantity?: number;
    wareHouseId?: number;
    wareHouseName?: string | undefined;
    documentId?: number | undefined;
}

export class TransferDto extends Transfer implements ITransferDto {
    statusName?: string | undefined;
    quantityStatusName?: string | undefined;
    sourceWareHouseName?: string | undefined;
    destinationWareHouseName?: string | undefined;

    constructor(data?: ITransferDto) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.statusName = _data["statusName"];
            this.quantityStatusName = _data["quantityStatusName"];
            this.sourceWareHouseName = _data["sourceWareHouseName"];
            this.destinationWareHouseName = _data["destinationWareHouseName"];
        }
    }

    static fromJS(data: any): TransferDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransferDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["statusName"] = this.statusName;
        data["quantityStatusName"] = this.quantityStatusName;
        data["sourceWareHouseName"] = this.sourceWareHouseName;
        data["destinationWareHouseName"] = this.destinationWareHouseName;
        super.toJSON(data);
        return data; 
    }
}

export interface ITransferDto extends ITransfer {
    statusName?: string | undefined;
    quantityStatusName?: string | undefined;
    sourceWareHouseName?: string | undefined;
    destinationWareHouseName?: string | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}